<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="author" content="Hower Lin">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>立体四子棋</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            touch-action: manipulation;
            -webkit-user-select: none;
            /* Safari/Chrome */
            -moz-user-select: none;
            /* Firefox */
            -ms-user-select: none;
            /* IE10+ */
            user-select: none;
        }

        body {
            background: linear-gradient(135deg, #0c1220, #1d2b50, #0c1220);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            color: white;
            overflow-x: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }

        /* 顶部标题栏 */
        .header-container {
            width: 100%;
            max-width: 800px;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
        }

        .game-title {
            font-size: 1.2rem;
            background: linear-gradient(to right, #00c9ff, #92fe9d);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header-controls {
            display: flex;
            gap: 10px;
        }

        .header-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        /* 主游戏区域 */
        .game-container {
            width: 100%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin: 5px 0;
        }

        /* 游戏状态栏 */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(30, 41, 59, 0.7);
            border-radius: 12px;
            padding: 10px;
            box-shadow: 0 0 16px rgba(0, 0, 0, 0.3);
        }

        .player-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 100px;
        }

        .player-info {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .player-timer {
            font-size: 0.8rem;
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 10px;
            margin-top: 3px;
            color: #4fc3f7;
            white-space: nowrap;
        }

        .player-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .player1-color {
            background: radial-gradient(circle at 30% 30%, #ff5252, #b33939);
        }

        .player2-color {
            background: radial-gradient(circle at 30% 30%, #448aff, #2962ff);
        }

        .ai-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #9c27b0;
        }

        .status {
            font-size: 1rem;
            font-weight: bold;
            text-align: center;
            flex-grow: 1;
            padding: 0 8px;
            transition: all 0.3s ease;
        }

        /* 游戏状态文本颜色 */
        .player1-turn {
            color: #ff5252;
            text-shadow: 0 0 8px rgba(255, 82, 82, 0.5);
        }

        .player2-turn {
            color: #448aff;
            text-shadow: 0 0 8px rgba(68, 138, 255, 0.5);
        }

        .win-status {
            color: #4caf50;
            text-shadow: 0 0 12px rgba(76, 175, 80, 0.7);
            animation: pulse-text 2s infinite;
        }

        .draw-status {
            color: #ffeb3b;
            text-shadow: 0 0 12px rgba(255, 235, 59, 0.7);
            animation: pulse-text 2s infinite;
        }

        .ai-thinking {
            color: #9c27b0;
            text-shadow: 0 0 8px rgba(156, 39, 176, 0.5);
            animation: pulse-text 1.5s infinite;
        }

        @keyframes pulse-text {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        /* 游戏网格区域 */
        .grid-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .layer-container {
            background: rgba(20, 30, 48, 0.7);
            border-radius: 10px;
            padding: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            position: relative;
        }

        .layer-title {
            text-align: center;
            font-size: 0.85rem;
            margin-bottom: 5px;
            color: #81d4fa;
        }

        .layer {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 2px;
            background: rgba(30, 41, 59, 0.5);
            padding: 6px;
            border-radius: 6px;
        }

        .cell {
            width: 100%;
            aspect-ratio: 1/1;
            background: rgba(40, 53, 80, 0.5);
            border-radius: 4px;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .cell:active {
            transform: scale(0.95);
        }

        .cell::before,
        .cell::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.1);
        }

        .cell::before {
            width: 100%;
            height: 1px;
            top: 50%;
            left: 0;
        }

        .cell::after {
            width: 1px;
            height: 100%;
            left: 50%;
            top: 0;
        }

        .piece {
            position: absolute;
            top: 10%;
            left: 10%;
            width: 80%;
            height: 80%;
            border-radius: 50%;
            z-index: 2;
            transition: transform 0.3s ease;
        }

        .piece.player1 {
            background: radial-gradient(circle at 30% 30%, #ff5252, #b33939);
        }

        .piece.player2 {
            background: radial-gradient(circle at 30% 30%, #448aff, #2962ff);
        }

        .piece.placed {
            transform: scale(1);
        }

        .winning-piece {
            animation: pulse 1.5s infinite;
            box-shadow: 0 0 8px #4caf50, 0 0 15px #4caf50;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
            }
        }

        /* 闪烁动画 - 无效位置 */
        @keyframes blink {
            0% {
                background-color: rgba(255, 0, 0, 0.3);
            }

            50% {
                background-color: rgba(255, 0, 0, 0.7);
            }

            100% {
                background-color: rgba(255, 0, 0, 0.3);
            }
        }

        .invalid-cell {
            animation: blink 0.8s ease 3;
        }

        /* 3D视图区域 */
        .view-section {
            background: rgba(20, 30, 48, 0.7);
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            height: 540px;
            position: relative;
        }

        #three-container {
            width: 100%;
            height: 100%;
            border-radius: 8px;
            overflow: hidden;
            background: #0a0f1a;
        }

        /* 规则弹窗 */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .modal.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: linear-gradient(135deg, #1a2a6c, #2c3e50);
            width: 90%;
            max-width: 400px;
            border-radius: 16px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            position: relative;
            max-height: 80vh;
            overflow-y: auto;
        }

        .close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 30px;
            height: 30px;
            background: #ff5252;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
            font-size: 18px;
        }

        .modal-title {
            text-align: center;
            font-size: 1.4rem;
            margin-bottom: 15px;
            color: #4fc3f7;
        }

        .rules-list {
            padding-left: 20px;
            margin-bottom: 20px;
        }

        .rules-list li {
            margin-bottom: 10px;
            line-height: 1.5;
        }

        /* 设置区域 */
        .settings-section {
            margin-top: 20px;
        }

        .setting-group {
            margin-bottom: 15px;
        }

        .hidden {
            display: none;
        }

        .setting-title {
            font-size: 1.1rem;
            margin-bottom: 10px;
            color: #81d4fa;
        }

        .options-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .option-btn {
            padding: 8px 16px;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 80px;
            text-align: center;
        }

        .option-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .option-btn.active {
            background: linear-gradient(135deg, #00c9ff, #92fe9d);
            color: #0c1220;
            font-weight: bold;
            border-color: rgba(0, 0, 0, 0.3);
        }

        /* AI难度选择 */
        .diff-btn {
            padding: 6px 12px;
            border-radius: 15px;
            background: rgba(156, 39, 176, 0.2);
            border: 1px solid rgba(156, 39, 176, 0.3);
            color: #e1bee7;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .diff-btn:hover {
            background: rgba(156, 39, 176, 0.3);
        }

        .diff-btn.active {
            background: linear-gradient(135deg, #9c27b0, #7b1fa2);
            color: white;
            font-weight: bold;
        }

        .player-order {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 15px;
        }

        .order-option {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .order-radio {
            width: 18px;
            height: 18px;
            border: 2px solid #81d4fa;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .order-radio::after {
            content: '';
            width: 10px;
            height: 10px;
            background: #00c9ff;
            border-radius: 50%;
            display: none;
        }

        .order-option.active .order-radio::after {
            display: block;
        }

        /* 标记样式 */
        .marker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 1;
            opacity: 0.7;
            pointer-events: none;
        }

        .marker::before,
        .marker::after {
            content: '';
            position: absolute;
            background-color: currentColor;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(45deg);
            width: 100%;
            height: 2px;
            border-radius: 1px;
        }

        .marker::after {
            transform: translate(-50%, -50%) rotate(-45deg);
        }

        .marker.player1 {
            color: #ff5252;
        }

        .marker.player2 {
            color: #448aff;
        }

        /* 立方体简笔画 */
        .cube-svg {
            width: 24px;
            height: 24px;
            fill: none;
            stroke: #fff;
            stroke-width: 2;
        }

        /* 响应式调整 - 电脑端 */
        @media (min-width: 768px) {
            .game-container {
                flex-direction: row;
                flex-wrap: wrap;
            }

            .status-bar {
                width: 100%;
            }

            .grid-container {
                flex: 1;
                max-width: 500px;
            }

            .view-section {
                flex: 0 0 280px;
                height: 540px;
                margin-left: 15px;
            }

            .header-container {
                padding: 12px;
            }

            .game-title {
                font-size: 1.3rem;
            }

            .status {
                font-size: 1.1rem;
            }

            .layer {
                padding: 8px;
                gap: 3px;
            }

            .player-indicator {
                min-width: 120px;
            }

            .player-timer {
                font-size: 0.9rem;
            }
        }

        /* 响应式调整 - 移动端 */
        @media (max-width: 767px) {
            .view-section {
                height: 220px;
            }
        }

        @media (max-width: 480px) {
            .player-indicator {
                min-width: 90px;
                gap: 6px;
            }

            .player-timer {
                font-size: 0.7rem;
                padding: 1px 5px;
            }

            .status {
                font-size: 0.9rem;
            }

            .header-controls {
                gap: 8px;
            }

            .header-btn {
                width: 32px;
                height: 32px;
                font-size: 14px;
            }
        }
    </style>
</head>

<body>
    <!-- 顶部标题栏 -->
    <div class="header-container">
        <div class="logo">
            <h1 class="game-title">立体四子棋</h1>
        </div>

        <div class="header-controls">
            <div class="header-btn" id="settings-btn" title="游戏设置">
                <i class="fas fa-cog"></i>
            </div>
            <div class="header-btn" id="restart" title="重新开始">
                <i class="fas fa-redo"></i>
            </div>
            <div class="header-btn" id="undo" title="悔棋">
                <i class="fas fa-undo"></i>
            </div>
            <div class="header-btn" id="reset-view" title="重置3D视图">
                <i class="fas fa-crosshairs"></i>
            </div>
            <div class="header-btn" id="show-rules" title="游戏规则">
                <i class="fas fa-question"></i>
            </div>
        </div>
    </div>

    <!-- 主游戏区域 -->
    <div class="game-container">
        <!-- 状态栏 -->
        <div class="status-bar">
            <div class="player-indicator">
                <div class="player-color player1-color"></div>
                <div class="player-info">
                    <span id="player1-name">玩家1</span>
                    <div class="player-timer" id="player1-timer">00:00</div>
                </div>
            </div>

            <div class="status player1-turn" id="status">玩家1回合</div>

            <div class="player-indicator" style="justify-content: end;">
                <div class="player-info">
                    <span id="player2-name">玩家2</span>
                    <div class="player-timer" id="player2-timer">00:00</div>
                </div>
                <div class="player-color player2-color"></div>
            </div>
        </div>

        <!-- 游戏网格 -->
        <div class="grid-container">
            <div class="layer-container">
                <div class="layer-title">第一层</div>
                <div class="layer" id="layer0"></div>
            </div>
            <div class="layer-container">
                <div class="layer-title">第二层</div>
                <div class="layer" id="layer1"></div>
            </div>
            <div class="layer-container">
                <div class="layer-title">第三层</div>
                <div class="layer" id="layer2"></div>
            </div>
            <div class="layer-container">
                <div class="layer-title">第四层</div>
                <div class="layer" id="layer3"></div>
            </div>
        </div>

        <!-- 3D视图 -->
        <div class="view-section">
            <div id="three-container"></div>
        </div>
    </div>

    <!-- 设置弹窗 -->
    <div class="modal" id="settings-modal">
        <div class="modal-content">
            <div class="close-btn hidden" id="close-settings">×</div>
            <h2 class="modal-title">游戏设置</h2>

            <div class="settings-section">
                <div id="mode-setting" class="setting-group">
                    <h3 class="setting-title">游戏模式</h3>
                    <div class="options-container">
                        <div class="option-btn active" id="pvp-mode">双人对战</div>
                        <div class="option-btn" id="pvc-mode">人机对战</div>
                    </div>
                </div>

                <div id="ai-diff-setting" class="setting-group hidden">
                    <h3 class="setting-title">AI难度</h3>
                    <div class="options-container">
                        <div class="option-btn diff-btn" id="easy-diff">简单</div>
                        <div class="option-btn diff-btn active" id="medium-diff">中等</div>
                        <div class="option-btn diff-btn" id="hard-diff">困难</div>
                    </div>
                </div>

                <div id="player-order-setting" class="setting-group hidden">
                    <h3 class="setting-title">玩家顺序</h3>
                    <div class="player-order">
                        <div class="order-option active" id="ai-second">
                            <div class="order-radio"></div>
                            <span>我先手</span>
                        </div>
                        <div class="order-option" id="ai-first">
                            <div class="order-radio"></div>
                            <span>AI先手</span>
                        </div>
                    </div>
                </div>
            </div>

            <button class="option-btn" id="apply-settings" style="width: 100%; margin-top: 20px;">
                开始挑战
            </button>
        </div>
    </div>

    <!-- 规则弹窗 -->
    <div class="modal" id="rules-modal">
        <div class="modal-content">
            <div class="close-btn" id="close-rules">×</div>
            <h2 class="modal-title">游戏规则</h2>
            <ul class="rules-list">
                <li>两个玩家轮流在4×4×4的立方体网格中放置棋子，可使用3D视图查看棋盘</li>
                <li>第一层（底层）可以直接放置棋子，其他层放置棋子时，正下方位置必须有棋子支撑</li>
                <li>在任意方向（横、竖、斜）连成四子即可获胜，获胜方向包括：水平线、垂直线、对角线、空间对角线</li>
                <li>右键点击(网页端)或长按(移动端): 添加/移除标记</li>
            </ul>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // 游戏状态
            const gameState = {
                currentPlayer: 1,
                board: Array(4).fill().map(() => Array(4).fill().map(() => Array(4).fill(0))),
                gameOver: false,
                moveHistory: [],
                winningPieces: [],
                timers: {
                    1: 0, // 玩家1的时间（秒）
                    2: 0  // 玩家2的时间（秒）
                },
                currentTimer: null,
                lastMoveTime: Date.now(),
                initialCameraPosition: null,
                firstMove: true, // 标记是否为第一步
                gameMode: 'pvp', // 'pvp' 或 'pvc'
                aiDifficulty: 'medium', // 'easy', 'medium', 'hard'
                aiPlayer: 2, // AI玩家编号
                isAiThinking: false, // AI是否正在思考
                markers: Array(4).fill().map(() => Array(4).fill().map(() => Array(4).fill(0))) // 标记状态
            };

            // Three.js 变量
            let scene, camera, renderer, controls;
            let boardGroup = new THREE.Group();
            let pieceMeshes = [];

            // 初始化Three.js场景
            function initThreeJS() {
                // 创建场景
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0a0f1a);
                scene.add(boardGroup);

                // 添加环境光
                const ambientLight = new THREE.AmbientLight(0x404040, 2);
                scene.add(ambientLight);

                // 添加平行光
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(5, 10, 7);
                scene.add(directionalLight);

                // 创建相机
                const container = document.getElementById('three-container');
                camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);

                // 根据设备类型调整相机初始位置
                if (window.innerWidth <= 767) { // 移动端
                    camera.position.set(3, 4, 5);
                } else { // 桌面端
                    camera.position.set(6, 6, 6);
                }

                camera.lookAt(0, 0, 0);

                // 保存初始相机位置
                gameState.initialCameraPosition = camera.position.clone();

                // 创建渲染器
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                container.appendChild(renderer.domElement);

                // 添加轨道控制器
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.enableZoom = true;
                controls.enablePan = false;

                // 设置缩放限制
                controls.minDistance = 4;  // 最小缩放距离
                controls.maxDistance = 15; // 最大缩放距离

                // 创建棋盘框架
                createBoardFrame();

                // 渲染循环
                function animate() {
                    requestAnimationFrame(animate);
                    controls.update();
                    renderer.render(scene, camera);
                }
                animate();

                // 响应窗口大小变化
                window.addEventListener('resize', () => {
                    camera.aspect = container.clientWidth / container.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(container.clientWidth, container.clientHeight);
                });
            }

            // 创建棋盘框架
            function createBoardFrame() {
                // 创建层分隔线
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0x3a6a9c });

                for (let level = 0; level <= 4; level++) {
                    for (let i = 0; i < 4; i++) {
                        for (let j = 0; j < 4; j++) {
                            if (i < 3) {
                                // 水平线
                                const horizontalPoints = [];
                                horizontalPoints.push(new THREE.Vector3(j - 1.5, level - 2, i - 1.5));
                                horizontalPoints.push(new THREE.Vector3(j - 1.5, level - 2, i - 0.5));

                                const horizontalLine = new THREE.Line(
                                    new THREE.BufferGeometry().setFromPoints(horizontalPoints),
                                    lineMaterial
                                );
                                boardGroup.add(horizontalLine);
                            }

                            if (j < 3) {
                                // 垂直线
                                const verticalPoints = [];
                                verticalPoints.push(new THREE.Vector3(j - 1.5, level - 2, i - 1.5));
                                verticalPoints.push(new THREE.Vector3(j - 0.5, level - 2, i - 1.5));

                                const verticalLine = new THREE.Line(
                                    new THREE.BufferGeometry().setFromPoints(verticalPoints),
                                    lineMaterial
                                );
                                boardGroup.add(verticalLine);
                            }
                        }
                    }
                }
            }

            // 添加3D棋子
            function add3DPiece(layer, row, col, player) {
                const pieceGeometry = new THREE.SphereGeometry(0.4, 32, 32);
                const pieceMaterial = new THREE.MeshPhongMaterial({
                    color: player === 1 ? 0xff5252 : 0x448aff,
                    emissive: 0x000000,
                    shininess: 60
                });

                const piece = new THREE.Mesh(pieceGeometry, pieceMaterial);
                piece.position.set(col - 1.5, layer - 1.5, row - 1.5);

                // 保存引用
                piece.userData = { layer, row, col, player };
                pieceMeshes.push(piece);
                boardGroup.add(piece);

                // 添加动画效果
                animatePieceScale(piece);
            }

            // 高亮获胜的棋子
            function highlightWinningPieces(winningPieces) {
                // 重置所有棋子高亮
                pieceMeshes.forEach(piece => {
                    piece.material.emissive.setHex(0x000000);
                    piece.material.needsUpdate = true;
                });

                // 高亮获胜的棋子
                winningPieces.forEach(pos => {
                    const piece = pieceMeshes.find(p =>
                        p.userData.layer === pos.layer &&
                        p.userData.row === pos.row &&
                        p.userData.col === pos.col
                    );

                    if (piece) {
                        piece.material.emissive.setHex(0x00ff00);
                        piece.material.needsUpdate = true;
                    }
                });
            }

            // 简单的动画函数
            function animatePieceScale(piece) {
                const startTime = Date.now();
                const duration = 400;

                function animate() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // 弹性动画效果
                    const scale = progress < 0.5
                        ? 2 * progress * progress
                        : -1 + (4 - 2 * progress) * progress;

                    piece.scale.set(scale, scale, scale);

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    }
                }

                animate();
            }

            // 初始化棋盘
            function initBoard() {
                for (let layer = 0; layer < 4; layer++) {
                    const layerElement = document.getElementById(`layer${layer}`);
                    layerElement.innerHTML = '';

                    for (let row = 0; row < 4; row++) {
                        for (let col = 0; col < 4; col++) {
                            const cell = document.createElement('div');
                            cell.className = 'cell';
                            cell.dataset.layer = layer;
                            cell.dataset.row = row;
                            cell.dataset.col = col;

                            // 添加自定义属性跟踪长按状态
                            cell.dataset.longPressTriggered = 'false';

                            // 添加点击事件
                            cell.addEventListener('click', (e) => {
                                // 检查是否由长按触发
                                if (cell.dataset.longPressTriggered === 'true') {
                                    cell.dataset.longPressTriggered = 'false';
                                    return;
                                }
                                makeMove(layer, row, col);
                            });

                            // 添加右键事件（标记）
                            cell.addEventListener('contextmenu', (e) => {
                                e.preventDefault();
                                toggleMarker(layer, row, col);
                            });

                            // 移动端触摸事件
                            let touchStartTime;
                            let touchMoved = false;

                            cell.addEventListener('touchstart', (e) => {
                                touchStartTime = Date.now();
                                touchMoved = false;
                                cell.dataset.longPressTriggered = 'false';

                                // 设置定时器检测长按
                                cell.longPressTimer = setTimeout(() => {
                                    if (!touchMoved) {
                                        toggleMarker(layer, row, col);
                                        cell.dataset.longPressTriggered = 'true';
                                    }
                                }, 500); // 500ms长按时间
                            });

                            cell.addEventListener('touchmove', () => {
                                touchMoved = true;
                                clearTimeout(cell.longPressTimer);
                            });

                            cell.addEventListener('touchend', (e) => {
                                clearTimeout(cell.longPressTimer);

                                // 如果是短按且未移动，可能触发点击事件
                                if (!touchMoved && Date.now() - touchStartTime < 500) {
                                    // 短按处理 - 由点击事件处理
                                }
                            });

                            layerElement.appendChild(cell);
                        }
                    }
                }
            }

            // 切换标记
            function toggleMarker(layer, row, col) {
                if (gameState.board[layer][row][col] !== 0 || gameState.isAiThinking) return; // 已有棋子不能标记

                const cell = document.querySelector(`.cell[data-layer="${layer}"][data-row="${row}"][data-col="${col}"]`);

                // 如果已有标记，则移除
                const existingMarker = cell.querySelector('.marker');
                if (existingMarker) {
                    cell.removeChild(existingMarker);
                    gameState.markers[layer][row][col] = 0;
                    return;
                }

                // 添加新标记
                const marker = document.createElement('div');
                marker.className = `marker player${gameState.currentPlayer}`;
                cell.appendChild(marker);
                gameState.markers[layer][row][col] = gameState.currentPlayer;
            }

            // 重置3D视图
            function reset3DView() {
                animateCamera(camera.position, gameState.initialCameraPosition.clone(), new THREE.Vector3(0, 0, 0));
            }

            // 相机动画
            function animateCamera(fromPos, toPos, lookAt) {
                const duration = 1000;
                const startTime = Date.now();
                const startPos = fromPos.clone();

                function update() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // 使用缓动函数
                    const easeProgress = easeInOutCubic(progress);

                    // 更新相机位置
                    camera.position.lerpVectors(startPos, toPos, easeProgress);

                    // 让相机始终看向目标位置
                    camera.lookAt(lookAt);

                    if (progress < 1) {
                        requestAnimationFrame(update);
                    } else {
                        // 更新控制器目标
                        controls.target.copy(lookAt);
                    }
                }

                update();
            }

            // 缓动函数
            function easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }

            // 开始计时器
            function startTimer() {
                if (gameState.currentTimer) {
                    clearInterval(gameState.currentTimer);
                }

                gameState.lastMoveTime = Date.now();

                gameState.currentTimer = setInterval(() => {
                    const now = Date.now();
                    const elapsedSeconds = Math.floor((now - gameState.lastMoveTime) / 1000);
                    gameState.timers[gameState.currentPlayer] += elapsedSeconds;
                    gameState.lastMoveTime = now;

                    updateTimerDisplay();
                }, 1000);
            }

            // 更新计时器显示
            function updateTimerDisplay() {
                // 更新玩家1计时器
                const minutes1 = Math.floor(gameState.timers[1] / 60);
                const seconds1 = gameState.timers[1] % 60;
                document.getElementById('player1-timer').textContent =
                    `${minutes1.toString().padStart(2, '0')}:${seconds1.toString().padStart(2, '0')}`;

                // 更新玩家2计时器
                const minutes2 = Math.floor(gameState.timers[2] / 60);
                const seconds2 = gameState.timers[2] % 60;
                document.getElementById('player2-timer').textContent =
                    `${minutes2.toString().padStart(2, '0')}:${seconds2.toString().padStart(2, '0')}`;
            }

            // 更新状态文本样式
            function updateStatusStyle() {
                const statusElement = document.getElementById('status');

                // 移除所有样式类
                statusElement.classList.remove(
                    'player1-turn',
                    'player2-turn',
                    'win-status',
                    'draw-status',
                    'ai-thinking'
                );

                if (gameState.isAiThinking) {
                    updateBarAndText('ai-thinking');
                    return;
                }

                if (gameState.gameOver) {
                    if (statusElement.textContent.includes('获胜')) {
                        updateBarAndText('win-status');
                    } else {
                        updateBarAndText('draw-status');
                    }
                } else {
                    if (gameState.currentPlayer === 1) {
                        updateBarAndText('player1-turn');
                    } else {
                        updateBarAndText('player2-turn');
                    }
                }
            }

            function updateBarAndText(status) {
                const statusColor = {
                    'player1-turn': 'rgba(255, 82, 82, 0.5)',
                    'player2-turn': 'rgba(68, 138, 255, 0.5)',
                    'win-status': 'rgba(76, 175, 80, 0.7)',
                    'draw-status': 'rgba(255, 235, 59, 0.7)',
                    'ai-thinking': 'rgba(156, 39, 176, 0.5)'
                }[status];
                const statusBarElement = document.querySelector('.status-bar');
                const statusTextElement = document.getElementById('status');
                statusBarElement.style.boxShadow = `0 0 16px ${statusColor}`;
                statusTextElement.classList.add(status);
            }

            // 下棋
            function makeMove(layer, row, col) {
                if (gameState.gameOver) return;
                if (gameState.isAiThinking) return;

                // 检查位置是否有效
                if (gameState.board[layer][row][col] !== 0) return;

                // 检查下方是否有支撑（第一层除外）
                if (layer > 0 && gameState.board[layer - 1][row][col] === 0) {
                    // 高亮显示下方需要支撑的位置
                    const belowCell = document.querySelector(`.cell[data-layer="${layer - 1}"][data-row="${row}"][data-col="${col}"]`);
                    if (belowCell) {
                        belowCell.classList.add('invalid-cell');
                        setTimeout(() => {
                            belowCell.classList.remove('invalid-cell');
                        }, 2400);
                    }

                    // 高亮显示当前尝试的位置
                    const currentCell = document.querySelector(`.cell[data-layer="${layer}"][data-row="${row}"][data-col="${col}"]`);
                    if (currentCell) {
                        currentCell.classList.add('invalid-cell');
                        setTimeout(() => {
                            currentCell.classList.remove('invalid-cell');
                        }, 2400);
                    }

                    return;
                }

                // 停止当前计时器，记录时间
                if (gameState.currentTimer && !gameState.firstMove) {
                    clearInterval(gameState.currentTimer);
                    const now = Date.now();
                    const elapsedSeconds = Math.floor((now - gameState.lastMoveTime) / 1000);
                    gameState.timers[gameState.currentPlayer] += elapsedSeconds;
                }

                // 记录移动历史
                gameState.moveHistory.push({ layer, row, col, player: gameState.currentPlayer });

                // 更新棋盘状态
                gameState.board[layer][row][col] = gameState.currentPlayer;

                // 移除该位置的标记
                gameState.markers[layer][row][col] = 0;
                const cell = document.querySelector(`.cell[data-layer="${layer}"][data-row="${row}"][data-col="${col}"]`);
                const marker = cell.querySelector('.marker');
                if (marker) {
                    cell.removeChild(marker);
                }

                // 在2D棋盘上放置棋子
                const piece = document.createElement('div');
                piece.className = `piece player${gameState.currentPlayer}`;
                cell.appendChild(piece);

                // 添加动画效果
                setTimeout(() => {
                    piece.classList.add('placed');
                    document.querySelectorAll('.placed').forEach(piece => {
                        piece.classList.remove('player-color');
                    });
                    if (!gameState.gameOver) {
                        piece.classList.add('player-color');
                    }
                }, 10);

                // 添加3D棋子
                add3DPiece(layer, row, col, gameState.currentPlayer);

                // 检查是否获胜
                const winInfo = checkWin(layer, row, col);
                if (winInfo.win) {
                    gameState.gameOver = true;
                    gameState.winningPieces = winInfo.winningPieces;
                    document.getElementById('status').textContent =
                        gameState.gameMode === 'pvp' ? `玩家${gameState.currentPlayer}获胜！` :
                            `${gameState.currentPlayer === gameState.aiPlayer ? 'AI' : '玩家'}获胜！`;
                    highlightWinningPieces(winInfo.winningPieces);
                    highlight2DWinningPieces();
                    updateStatusStyle();

                    // 停止计时器
                    if (gameState.currentTimer) {
                        clearInterval(gameState.currentTimer);
                    }
                    return;
                }

                // 检查是否平局
                if (checkDraw()) {
                    gameState.gameOver = true;
                    document.getElementById('status').textContent = '平局！';
                    updateStatusStyle();

                    // 停止计时器
                    if (gameState.currentTimer) {
                        clearInterval(gameState.currentTimer);
                    }
                    return;
                }

                // 切换玩家
                gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;

                // 更新状态文本
                if (gameState.gameMode === 'pvp') {
                    document.getElementById('status').textContent = `玩家${gameState.currentPlayer}回合`;
                } else {
                    if (gameState.currentPlayer === gameState.aiPlayer) {
                        document.getElementById('status').textContent = 'AI思考中...';
                    } else {
                        document.getElementById('status').textContent = '玩家回合';
                    }
                }

                updateStatusStyle();

                // 第一步棋不计时，从第二步开始计时
                if (gameState.firstMove) {
                    gameState.firstMove = false;
                } else {
                    // 为新玩家启动计时器
                    startTimer();
                }

                // 如果是人机模式且轮到AI，则让AI下棋
                if (gameState.gameMode === 'pvc' && gameState.currentPlayer === gameState.aiPlayer && !gameState.gameOver) {
                    aiMakeMove();
                }
            }

            // 高亮2D获胜棋子
            function highlight2DWinningPieces() {
                // 高亮获胜棋子
                gameState.winningPieces.forEach(pos => {
                    const cell = document.querySelector(`.cell[data-layer="${pos.layer}"][data-row="${pos.row}"][data-col="${pos.col}"]`);
                    if (cell && cell.firstChild) {
                        cell.firstChild.classList.add('winning-piece');
                    }
                });
            }

            // 检查是否获胜
            function checkWin(layer, row, col) {
                const player = gameState.board[layer][row][col];
                if (player === 0) return { win: false, winningPieces: [] };

                // 检查方向
                const directions = [
                    // 同一层方向
                    [0, 0, 1], [0, 1, 0], [0, 1, 1], [0, 1, -1],

                    // 垂直方向
                    [1, 0, 0],

                    // 垂直平面内的对角线
                    [1, 1, 0], [1, -1, 0], [1, 0, 1], [1, 0, -1],

                    // 空间对角线
                    [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1],

                    // 垂直平面内的其他斜线方向
                    [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1],
                    [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1]
                ];

                for (const [dl, dr, dc] of directions) {
                    let count = 1;
                    let winningPieces = [];

                    // 正向检查
                    const forward = countDirection(layer, row, col, dl, dr, dc, player);
                    count += forward.count;
                    winningPieces = winningPieces.concat(forward.pieces);

                    // 反向检查
                    const backward = countDirection(layer, row, col, -dl, -dr, -dc, player);
                    count += backward.count;
                    winningPieces = winningPieces.concat(backward.pieces);

                    if (count >= 4) {
                        winningPieces.push({ layer, row, col });
                        return {
                            win: true,
                            winningPieces: winningPieces.slice(0, 4)
                        };
                    }
                }

                return { win: false, winningPieces: [] };
            }

            // 计算指定方向上的连续棋子数
            function countDirection(layer, row, col, dl, dr, dc, player) {
                let count = 0;
                let pieces = [];
                let l = layer + dl;
                let r = row + dr;
                let c = col + dc;

                while (l >= 0 && l < 4 && r >= 0 && r < 4 && c >= 0 && c < 4) {
                    if (gameState.board[l][r][c] === player) {
                        count++;
                        pieces.push({ layer: l, row: r, col: c });
                        l += dl;
                        r += dr;
                        c += dc;
                    } else {
                        break;
                    }
                }

                return { count, pieces };
            }

            // 检查是否平局
            function checkDraw() {
                for (let layer = 0; layer < 4; layer++) {
                    for (let row = 0; row < 4; row++) {
                        for (let col = 0; col < 4; col++) {
                            if (gameState.board[layer][row][col] === 0) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            // 悔棋
            function undoMove() {
                if (gameState.moveHistory.length === 0) return;
                if (gameState.isAiThinking) return;

                // 停止当前计时器，记录时间
                if (gameState.currentTimer && !gameState.firstMove) {
                    clearInterval(gameState.currentTimer);
                    const now = Date.now();
                    const elapsedSeconds = Math.floor((now - gameState.lastMoveTime) / 1000);
                    gameState.timers[gameState.currentPlayer] += elapsedSeconds;
                }

                // 如果游戏已结束，撤销获胜状态
                if (gameState.gameOver) {
                    // 重置获胜状态
                    gameState.winningPieces = [];
                    highlightWinningPieces([]);
                    document.querySelectorAll('.winning-piece').forEach(piece => {
                        piece.classList.remove('winning-piece');
                    });
                    gameState.gameOver = false;

                    // 如果是双人对战，则多撤回一步，让败方重下
                    if (gameState.gameMode === 'pvp') {
                        undoMove();
                    }
                }

                // 撤回一步
                const lastMove = gameState.moveHistory.pop();
                gameState.board[lastMove.layer][lastMove.row][lastMove.col] = 0;

                // 移除2D棋子
                const cell = document.querySelector(`.cell[data-layer="${lastMove.layer}"][data-row="${lastMove.row}"][data-col="${lastMove.col}"]`);
                cell.innerHTML = '';

                // 移除3D棋子
                const index = pieceMeshes.findIndex(piece =>
                    piece.userData.layer === lastMove.layer &&
                    piece.userData.row === lastMove.row &&
                    piece.userData.col === lastMove.col
                );

                if (index !== -1) {
                    boardGroup.remove(pieceMeshes[index]);
                    pieceMeshes.splice(index, 1);
                }

                // 切换回上一个玩家
                gameState.currentPlayer = lastMove.player;

                // 人机模式特殊处理：如果当前是AI回合，再撤一步（撤回AI的移动）
                if (gameState.gameMode === 'pvc' &&
                    gameState.currentPlayer === gameState.aiPlayer &&
                    gameState.moveHistory.length > 0) {

                    const aiMove = gameState.moveHistory.pop();
                    gameState.board[aiMove.layer][aiMove.row][aiMove.col] = 0;

                    const aiCell = document.querySelector(`.cell[data-layer="${aiMove.layer}"][data-row="${aiMove.row}"][data-col="${aiMove.col}"]`);
                    aiCell.innerHTML = '';

                    const aiIndex = pieceMeshes.findIndex(piece =>
                        piece.userData.layer === aiMove.layer &&
                        piece.userData.row === aiMove.row &&
                        piece.userData.col === aiMove.col
                    );

                    if (aiIndex !== -1) {
                        boardGroup.remove(pieceMeshes[aiIndex]);
                        pieceMeshes.splice(aiIndex, 1);
                    }

                    gameState.currentPlayer = aiMove.player;
                }

                // 更新状态文本
                if (gameState.gameMode === 'pvp') {
                    document.getElementById('status').textContent = `玩家${gameState.currentPlayer}回合`;
                } else {
                    if (gameState.currentPlayer === gameState.aiPlayer) {
                        document.getElementById('status').textContent = 'AI思考中...';
                    } else {
                        document.getElementById('status').textContent = '玩家回合';
                    }
                }
                updateStatusStyle();

                // 如果是第一步，重置firstMove状态
                if (gameState.moveHistory.length === 0) {
                    gameState.firstMove = true;
                } else {
                    // 启动计时器
                    startTimer();
                }
            }

            // 重新开始游戏
            function restartGame() {
                // 停止计时器
                if (gameState.currentTimer) {
                    clearInterval(gameState.currentTimer);
                    gameState.currentTimer = null;
                }

                // 重置游戏状态
                gameState.currentPlayer = 1;
                gameState.board = Array(4).fill().map(() => Array(4).fill().map(() => Array(4).fill(0)));
                gameState.gameOver = false;
                gameState.moveHistory = [];
                gameState.winningPieces = [];
                gameState.timers = { 1: 0, 2: 0 };
                gameState.firstMove = true;
                gameState.isAiThinking = false;
                gameState.markers = Array(4).fill().map(() => Array(4).fill().map(() => Array(4).fill(0)));

                // 更新UI
                document.querySelectorAll('.piece').forEach(piece => piece.remove());
                document.querySelectorAll('.marker').forEach(marker => marker.remove());
                document.getElementById('status').textContent =
                    gameState.gameMode === 'pvp' ? '玩家1回合' :
                        gameState.aiPlayer === 1 ? 'AI思考中...' : '玩家回合';
                updateTimerDisplay();
                updateStatusStyle();

                // 移除获胜高亮
                document.querySelectorAll('.winning-piece').forEach(piece => {
                    piece.classList.remove('winning-piece');
                });

                // 重置3D棋盘
                pieceMeshes.forEach(piece => boardGroup.remove(piece));
                pieceMeshes = [];

                // 重置3D视图
                reset3DView();

                // 如果是人机模式且AI先手，则让AI下第一步
                if (gameState.gameMode === 'pvc' && gameState.aiPlayer === 1) {
                    setTimeout(() => aiMakeMove(), 800);
                }
            }

            // 获取所有合法移动
            function getValidMoves() {
                const validMoves = [];
                for (let layer = 0; layer < 4; layer++) {
                    for (let row = 0; row < 4; row++) {
                        for (let col = 0; col < 4; col++) {
                            // 检查位置是否为空
                            if (gameState.board[layer][row][col] !== 0) continue;

                            // 检查下方是否有支撑（第一层除外）
                            if (layer === 0 || gameState.board[layer - 1][row][col] !== 0) {
                                validMoves.push({ layer, row, col });
                            }
                        }
                    }
                }
                return validMoves;
            }

            // 评估棋盘状态
            function evaluateBoard(player) {
                let score = 0;
                const opponent = player === 1 ? 2 : 1;

                // 检查所有位置
                for (let layer = 0; layer < 4; layer++) {
                    for (let row = 0; row < 4; row++) {
                        for (let col = 0; col < 4; col++) {
                            if (gameState.board[layer][row][col] === player) {
                                // 评估这个位置对玩家的价值
                                score += evaluatePosition(layer, row, col, player);
                            } else if (gameState.board[layer][row][col] === opponent) {
                                // 减去对手的价值
                                score -= evaluatePosition(layer, row, col, opponent);
                            }
                        }
                    }
                }
                return score;
            }

            // 评估位置的价值
            function evaluatePosition(layer, row, col, player) {
                let score = 0;
                const opponent = player === 1 ? 2 : 1;

                // 检查方向
                const directions = [
                    [0, 0, 1], [0, 1, 0], [0, 1, 1], [0, 1, -1],
                    [1, 0, 0], [1, 1, 0], [1, -1, 0], [1, 0, 1],
                    [1, 0, -1], [1, 1, 1], [1, 1, -1], [1, -1, 1],
                    [1, -1, -1]
                ];

                for (const [dl, dr, dc] of directions) {
                    // 正向检查
                    let count = 1;
                    let empty = 0;
                    let l = layer + dl;
                    let r = row + dr;
                    let c = col + dc;

                    // 正向检查
                    while (l >= 0 && l < 4 && r >= 0 && r < 4 && c >= 0 && c < 4) {
                        if (gameState.board[l][r][c] === player) {
                            count++;
                        } else if (gameState.board[l][r][c] === 0) {
                            empty++;
                            break; // 遇到空位停止
                        } else {
                            break; // 对手棋子阻挡
                        }
                        l += dl;
                        r += dr;
                        c += dc;
                    }

                    // 反向检查
                    l = layer - dl;
                    r = row - dr;
                    c = col - dc;
                    while (l >= 0 && l < 4 && r >= 0 && r < 4 && c >= 0 && c < 4) {
                        if (gameState.board[l][r][c] === player) {
                            count++;
                        } else if (gameState.board[l][r][c] === 0) {
                            empty++;
                            break;
                        } else {
                            break;
                        }
                        l -= dl;
                        r -= dr;
                        c -= dc;
                    }

                    // 根据连续棋子数和空位加分
                    if (count >= 4) {
                        score += 1000; // 获胜
                    } else if (count === 3 && empty >= 1) {
                        score += 100; // 三连且有一端开放
                    } else if (count === 2 && empty >= 1) {
                        score += 10; // 二连且有一端开放
                    } else if (count === 1 && empty >= 1) {
                        score += 1; // 单子
                    }
                }

                return score;
            }

            // 简单难度的AI
            function easyAIMove(validMoves) {
                // 1. 检查AI是否可以立即获胜
                for (const move of validMoves) {
                    gameState.board[move.layer][move.row][move.col] = gameState.aiPlayer;
                    if (checkWin(move.layer, move.row, move.col).win) {
                        gameState.board[move.layer][move.row][move.col] = 0;
                        return move;
                    }
                    gameState.board[move.layer][move.row][move.col] = 0;
                }

                // 2. 检查玩家是否可以获胜（需要阻止）
                for (const move of validMoves) {
                    gameState.board[move.layer][move.row][move.col] = gameState.aiPlayer === 1 ? 2 : 1;
                    if (checkWin(move.layer, move.row, move.col).win) {
                        gameState.board[move.layer][move.row][move.col] = 0;
                        return move;
                    }
                    gameState.board[move.layer][move.row][move.col] = 0;
                }

                // 3. 策略性选择（中心位置优先）
                const movesWithScores = validMoves.map(move => {
                    // 中心位置得分高
                    const centerDist =
                        Math.abs(move.row - 1.5) +
                        Math.abs(move.col - 1.5) +
                        Math.abs(move.layer - 1.5);
                    let score = 10 - centerDist;

                    // 高层位置得分降低（降低空间层面策略）
                    if (move.layer > 0) {
                        score *= 0.8; // 降低高层位置的重要性
                    }

                    // 增加随机性
                    const randomFactor = Math.random() * 7;

                    return { move, score: score + randomFactor };
                });

                // 按分数排序
                movesWithScores.sort((a, b) => b.score - a.score);

                // 选择分数最高的移动
                return movesWithScores[0].move;
            }

            // 中等难度的AI
            function mediumAIMove(validMoves) {
                // 1. 检查AI是否可以立即获胜
                for (const move of validMoves) {
                    gameState.board[move.layer][move.row][move.col] = gameState.aiPlayer;
                    if (checkWin(move.layer, move.row, move.col).win) {
                        gameState.board[move.layer][move.row][move.col] = 0;
                        return move;
                    }
                    gameState.board[move.layer][move.row][move.col] = 0;
                }

                // 2. 检查玩家是否可以获胜（需要阻止）
                for (const move of validMoves) {
                    gameState.board[move.layer][move.row][move.col] = gameState.aiPlayer === 1 ? 2 : 1;
                    if (checkWin(move.layer, move.row, move.col).win) {
                        gameState.board[move.layer][move.row][move.col] = 0;
                        return move;
                    }
                    gameState.board[move.layer][move.row][move.col] = 0;
                }

                // 3. 策略性选择
                const movesWithScores = validMoves.map(move => {
                    let score = 0;

                    // 位置权重：中心位置得分更高
                    const centerDist =
                        Math.abs(move.row - 1.5) +
                        Math.abs(move.col - 1.5) +
                        Math.abs(move.layer - 1.5);
                    score += (6 - centerDist) * 2;

                    // 检查该位置是否可以形成连线
                    score += evaluatePosition(move.layer, move.row, move.col, gameState.aiPlayer);

                    // 考虑对手的威胁，但权重较低
                    score -= evaluatePosition(move.layer, move.row, move.col, gameState.aiPlayer === 1 ? 2 : 1) * 0.7;

                    // 随机性，避免AI行为过于可预测
                    score += Math.random() * 3;

                    return { move, score };
                });

                // 按分数排序
                movesWithScores.sort((a, b) => b.score - a.score);

                // 选择分数最高的移动
                return movesWithScores[0].move;
            }

            // 困难难度的AI（优化后）
            function hardAIMove(validMoves) {
                const opponent = gameState.aiPlayer === 1 ? 2 : 1;
                let bestScore = -Infinity;
                let bestMoves = []; // 存储所有最佳移动

                // 1. 检查AI是否可以立即获胜
                for (const move of validMoves) {
                    gameState.board[move.layer][move.row][move.col] = gameState.aiPlayer;
                    if (checkWin(move.layer, move.row, move.col).win) {
                        gameState.board[move.layer][move.row][move.col] = 0;
                        return move;
                    }
                    gameState.board[move.layer][move.row][move.col] = 0;
                }

                // 2. 检查玩家是否可以立即获胜
                for (const move of validMoves) {
                    gameState.board[move.layer][move.row][move.col] = opponent;
                    if (checkWin(move.layer, move.row, move.col).win) {
                        gameState.board[move.layer][move.row][move.col] = 0;
                        return move; // 拦截获胜
                    }
                    gameState.board[move.layer][move.row][move.col] = 0;
                }

                // 3. 增强的Minimax算法
                const depth = 2; // 搜索深度
                for (const move of validMoves) {
                    // 模拟AI移动
                    gameState.board[move.layer][move.row][move.col] = gameState.aiPlayer;

                    // 使用递归搜索计算分数
                    const score = minimax(depth, false, -Infinity, Infinity);

                    // 恢复棋盘状态
                    gameState.board[move.layer][move.row][move.col] = 0;

                    // 更新最佳移动
                    if (score > bestScore) {
                        bestScore = score;
                        bestMoves = [move]; // 重置最佳移动列表
                    } else if (score === bestScore) {
                        bestMoves.push(move); // 添加同样优秀的移动
                    }
                }

                // 4. 增加随机性 - 从所有最佳移动中随机选择
                if (bestMoves.length > 0) {
                    return bestMoves[Math.floor(Math.random() * bestMoves.length)];
                }

                // 5. 如果没有找到最佳移动，则随机选择
                return validMoves[Math.floor(Math.random() * validMoves.length)];
            }

            // 递归Minimax算法（带α-β剪枝）
            function minimax(depth, isMaximizing, alpha, beta) {
                // 检查游戏是否结束
                const winInfo = checkWinForPlayer(isMaximizing ? gameState.aiPlayer : (gameState.aiPlayer === 1 ? 2 : 1));
                if (winInfo.win) {
                    return isMaximizing ? -1000 + depth : 1000 - depth;
                }

                if (depth === 0 || checkDraw()) {
                    return evaluateBoard(gameState.aiPlayer);
                }

                const player = isMaximizing ? gameState.aiPlayer : (gameState.aiPlayer === 1 ? 2 : 1);
                const validMoves = getValidMoves();

                if (isMaximizing) {
                    let maxScore = -Infinity;
                    for (const move of validMoves) {
                        gameState.board[move.layer][move.row][move.col] = player;
                        const score = minimax(depth - 1, false, alpha, beta);
                        gameState.board[move.layer][move.row][move.col] = 0;

                        maxScore = Math.max(maxScore, score);
                        alpha = Math.max(alpha, score);
                        if (beta <= alpha) break; // α-β剪枝
                    }
                    return maxScore;
                } else {
                    let minScore = Infinity;
                    for (const move of validMoves) {
                        gameState.board[move.layer][move.row][move.col] = player;
                        const score = minimax(depth - 1, true, alpha, beta);
                        gameState.board[move.layer][move.row][move.col] = 0;

                        minScore = Math.min(minScore, score);
                        beta = Math.min(beta, score);
                        if (beta <= alpha) break; // α-β剪枝
                    }
                    return minScore;
                }
            }

            // 检查特定玩家是否获胜
            function checkWinForPlayer(player) {
                for (let layer = 0; layer < 4; layer++) {
                    for (let row = 0; row < 4; row++) {
                        for (let col = 0; col < 4; col++) {
                            if (gameState.board[layer][row][col] === player) {
                                const winInfo = checkWin(layer, row, col);
                                if (winInfo.win) {
                                    return winInfo;
                                }
                            }
                        }
                    }
                }
                return { win: false, winningPieces: [] };
            }

            // 增强的评估函数
            function evaluateBoard(player) {
                let score = 0;
                const opponent = player === 1 ? 2 : 1;

                // 空间策略评估
                score += evaluateSpatialStrategy(player, opponent);

                // 中心控制评估
                score += evaluateCenterControl(player, opponent);

                // 威胁评估
                score += evaluateThreats(player, opponent);

                // 增加少量随机性
                const randomFactor = Math.random() * 5 - 2.5; // -2.5到+2.5之间的随机数
                return score + randomFactor;
            }

            // 空间策略评估
            function evaluateSpatialStrategy(player, opponent) {
                let score = 0;

                // 评估空间连线潜力
                for (let layer = 0; layer < 4; layer++) {
                    for (let row = 0; row < 4; row++) {
                        for (let col = 0; col < 4; col++) {
                            if (gameState.board[layer][row][col] === player) {
                                score += evaluatePosition(layer, row, col, player) * 1.5;
                            } else if (gameState.board[layer][row][col] === opponent) {
                                score -= evaluatePosition(layer, row, col, opponent) * 1.2;
                            }
                        }
                    }
                }

                return score;
            }

            // 中心控制评估
            function evaluateCenterControl(player, opponent) {
                let score = 0;
                const centerPositions = [
                    { layer: 1, row: 1, col: 1 }, { layer: 1, row: 1, col: 2 },
                    { layer: 1, row: 2, col: 1 }, { layer: 1, row: 2, col: 2 },
                    { layer: 2, row: 1, col: 1 }, { layer: 2, row: 1, col: 2 },
                    { layer: 2, row: 2, col: 1 }, { layer: 2, row: 2, col: 2 }
                ];

                for (const pos of centerPositions) {
                    if (gameState.board[pos.layer][pos.row][pos.col] === player) {
                        score += 15;
                    } else if (gameState.board[pos.layer][pos.row][pos.col] === opponent) {
                        score -= 15;
                    }
                }

                return score;
            }

            // 威胁评估
            function evaluateThreats(player, opponent) {
                let score = 0;

                // 检查玩家威胁
                score += evaluatePlayerThreats(player) * 2;

                // 检查对手威胁
                score -= evaluatePlayerThreats(opponent) * 1.8;

                return score;
            }

            // 评估玩家的威胁
            function evaluatePlayerThreats(player) {
                let threatScore = 0;

                for (let layer = 0; layer < 4; layer++) {
                    for (let row = 0; row < 4; row++) {
                        for (let col = 0; col < 4; col++) {
                            if (gameState.board[layer][row][col] === 0) {
                                // 检查如果玩家下在此处的威胁
                                gameState.board[layer][row][col] = player;
                                const winInfo = checkWin(layer, row, col);
                                if (winInfo.win) {
                                    threatScore += 100; // 直接获胜
                                } else {
                                    // 检查是否形成三连
                                    const directions = [
                                        [0, 0, 1], [0, 1, 0], [0, 1, 1], [0, 1, -1],
                                        [1, 0, 0], [1, 1, 0], [1, -1, 0], [1, 0, 1],
                                        [1, 0, -1], [1, 1, 1], [1, 1, -1], [1, -1, 1],
                                        [1, -1, -1]
                                    ];

                                    for (const [dl, dr, dc] of directions) {
                                        let count = 1;

                                        // 正向检查
                                        let l = layer + dl, r = row + dr, c = col + dc;
                                        while (l >= 0 && l < 4 && r >= 0 && r < 4 && c >= 0 && c < 4) {
                                            if (gameState.board[l][r][c] === player) {
                                                count++;
                                                l += dl;
                                                r += dr;
                                                c += dc;
                                            } else {
                                                break;
                                            }
                                        }

                                        // 反向检查
                                        l = layer - dl, r = row - dr, c = col - dc;
                                        while (l >= 0 && l < 4 && r >= 0 && r < 4 && c >= 0 && c < 4) {
                                            if (gameState.board[l][r][c] === player) {
                                                count++;
                                                l -= dl;
                                                r -= dr;
                                                c -= dc;
                                            } else {
                                                break;
                                            }
                                        }

                                        if (count >= 3) {
                                            threatScore += 30; // 三连威胁
                                        } else if (count >= 2) {
                                            threatScore += 10; // 二连威胁
                                        }
                                    }
                                }
                                gameState.board[layer][row][col] = 0;
                            }
                        }
                    }
                }

                return threatScore;
            }

            // AI下棋逻辑
            function aiMakeMove() {
                if (gameState.gameOver) return;

                gameState.isAiThinking = true;
                document.getElementById('status').textContent = 'AI思考中...';
                updateStatusStyle();

                // 计算当前棋盘上的棋子数量
                const moveCount = gameState.moveHistory.length;

                // 基础思考时间
                let baseThinkTime;
                switch (gameState.aiDifficulty) {
                    case 'easy':
                        baseThinkTime = 600;
                        break;
                    case 'medium':
                        baseThinkTime = 900;
                        break;
                    case 'hard':
                        baseThinkTime = 1200;
                        break;
                    default:
                        baseThinkTime = 900;
                }

                // 根据棋子数量动态调整思考时间
                let dynamicFactor = 1 + moveCount * 0.1; // 每增加一步思考时间增加10%
                dynamicFactor = Math.min(dynamicFactor, 2.5); // 最大不超过2.5倍

                // 添加随机性，避免过于机械
                const randomFactor = 0.8 + Math.random() * 0.4; // 0.8-1.2之间的随机数

                // 最终思考时间 = 基础时间 × 动态因子 × 随机因子
                const thinkTime = baseThinkTime * dynamicFactor * randomFactor;

                // 确保思考时间在合理范围内
                const minTime = 300; // 最小300ms
                const maxTime = 3500; // 最大3500ms
                const clampedThinkTime = Math.max(minTime, Math.min(maxTime, thinkTime));

                setTimeout(() => {
                    if (gameState.gameOver || gameState.currentPlayer !== gameState.aiPlayer) {
                        gameState.isAiThinking = false;
                        return;
                    }

                    gameState.isAiThinking = false;

                    // 获取所有合法移动
                    const validMoves = getValidMoves();

                    // 如果没有合法移动，则返回
                    if (validMoves.length === 0) return;

                    let selectedMove;

                    // 根据难度选择AI策略
                    switch (gameState.aiDifficulty) {
                        case 'easy':
                            selectedMove = easyAIMove(validMoves);
                            break;
                        case 'medium':
                            selectedMove = mediumAIMove(validMoves);
                            break;
                        case 'hard':
                            selectedMove = hardAIMove(validMoves);
                            break;
                    }

                    // 执行AI选择的移动
                    if (selectedMove) {
                        makeMove(selectedMove.layer, selectedMove.row, selectedMove.col);
                    } else if (validMoves.length > 0) {
                        // 如果未选择移动但存在合法移动，则随机选择一个
                        selectedMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                        makeMove(selectedMove.layer, selectedMove.row, selectedMove.col);
                    }
                }, clampedThinkTime);
            }

            // 切换游戏模式
            function setGameMode(mode) {
                gameState.gameMode = mode;

                // 更新按钮状态
                document.getElementById('pvp-mode').classList.toggle('active', mode === 'pvp');
                document.getElementById('pvc-mode').classList.toggle('active', mode === 'pvc');

                // 更新玩家名称
                if (mode === 'pvp') {
                    document.getElementById('player1-name').textContent = '玩家1';
                    document.getElementById('player2-name').textContent = '玩家2';
                } else {
                    const aiDifficulty = {
                        easy: '简单',
                        medium: '中等',
                        hard: '困难'
                    }[gameState.aiDifficulty]
                    document.getElementById('player1-name').textContent = gameState.aiPlayer === 1 ? (aiDifficulty + 'AI') : '玩家';
                    document.getElementById('player2-name').textContent = gameState.aiPlayer === 2 ? (aiDifficulty + 'AI') : '玩家';
                }
            }

            // 设置AI难度
            function setAIDifficulty(difficulty) {
                gameState.aiDifficulty = difficulty;

                // 更新按钮状态
                document.getElementById('easy-diff').classList.toggle('active', difficulty === 'easy');
                document.getElementById('medium-diff').classList.toggle('active', difficulty === 'medium');
                document.getElementById('hard-diff').classList.toggle('active', difficulty === 'hard');
            }

            // 设置玩家顺序
            function setPlayerOrder(isAiFirst) {
                const aiDifficulty = {
                    easy: '简单',
                    medium: '中等',
                    hard: '困难'
                }[gameState.aiDifficulty]
                gameState.aiPlayer = isAiFirst ? 1 : 2;

                // 更新UI
                document.getElementById('ai-first').classList.toggle('active', isAiFirst);
                document.getElementById('ai-second').classList.toggle('active', !isAiFirst);

                // 更新玩家名称
                if (gameState.gameMode === 'pvc') {
                    document.getElementById('player1-name').textContent = gameState.aiPlayer === 1 ? (aiDifficulty + 'AI') : '玩家';
                    document.getElementById('player2-name').textContent = gameState.aiPlayer === 2 ? (aiDifficulty + 'AI') : '玩家';
                }
            }

            // 应用设置
            function applySettings() {
                // 获取当前设置
                const isPvCMode = document.getElementById('pvc-mode').classList.contains('active');
                const difficulty = document.getElementById('hard-diff').classList.contains('active') ? 'hard' :
                    document.getElementById('medium-diff').classList.contains('active') ? 'medium' : 'easy';
                const isAiFirst = document.getElementById('ai-first').classList.contains('active');

                // 更新游戏状态
                setGameMode(isPvCMode ? 'pvc' : 'pvp');
                setAIDifficulty(difficulty);
                setPlayerOrder(isAiFirst);

                // 关闭设置弹窗
                document.getElementById('settings-modal').classList.remove('active');

                // 重新开始游戏
                restartGame();

                setTimeout(() => {
                    document.getElementById('close-settings').classList.remove('hidden');
                }, 1000);
            }

            // 事件监听
            document.getElementById('restart').addEventListener('click', restartGame);
            document.getElementById('undo').addEventListener('click', undoMove);
            document.getElementById('reset-view').addEventListener('click', reset3DView);
            document.getElementById('show-rules').addEventListener('click', () => {
                document.getElementById('rules-modal').classList.add('active');
            });
            document.getElementById('close-rules').addEventListener('click', () => {
                document.getElementById('rules-modal').classList.remove('active');
            });

            // 设置按钮
            document.getElementById('settings-btn').addEventListener('click', () => {
                document.getElementById('settings-modal').classList.add('active');
            });
            document.getElementById('close-settings').addEventListener('click', () => {
                document.getElementById('settings-modal').classList.remove('active');
            });
            document.getElementById('apply-settings').addEventListener('click', applySettings);

            // 模式选择
            document.getElementById('pvp-mode').addEventListener('click', () => {
                document.getElementById('pvp-mode').classList.add('active');
                document.getElementById('pvc-mode').classList.remove('active');
                document.getElementById('ai-diff-setting').classList.add('hidden');
                document.getElementById('player-order-setting').classList.add('hidden');
            });
            document.getElementById('pvc-mode').addEventListener('click', () => {
                document.getElementById('pvc-mode').classList.add('active');
                document.getElementById('pvp-mode').classList.remove('active');
                document.getElementById('ai-diff-setting').classList.remove('hidden');
                document.getElementById('player-order-setting').classList.remove('hidden');
            });

            // 难度选择
            document.getElementById('easy-diff').addEventListener('click', () => {
                setAIDifficulty('easy');
            });
            document.getElementById('medium-diff').addEventListener('click', () => {
                setAIDifficulty('medium');
            });
            document.getElementById('hard-diff').addEventListener('click', () => {
                setAIDifficulty('hard');
            });

            // 玩家顺序
            document.getElementById('ai-first').addEventListener('click', () => {
                setPlayerOrder(true);
            });
            document.getElementById('ai-second').addEventListener('click', () => {
                setPlayerOrder(false);
            });

            // 初始化游戏
            initBoard();
            initThreeJS();
            document.getElementById('settings-modal').classList.add('active');
        });
    </script>
</body>

</html>
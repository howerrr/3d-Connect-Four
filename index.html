<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>立体四子棋</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            touch-action: manipulation;
        }
        
        body {
            background: linear-gradient(135deg, #0c1220, #1d2b50, #0c1220);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            color: white;
            overflow-x: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }
        
        /* 顶部标题栏 */
        .header-container {
            width: 100%;
            max-width: 800px;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .logo-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #00c9ff, #92fe9d);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 20px;
        }
        
        .game-title {
            font-size: 1.2rem;
            background: linear-gradient(to right, #00c9ff, #92fe9d);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .header-controls {
            display: flex;
            gap: 10px;
        }
        
        .header-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .header-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        /* 主游戏区域 */
        .game-container {
            width: 100%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin: 5px 0;
        }
        
        /* 游戏状态栏 */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(30, 41, 59, 0.7);
            border-radius: 12px;
            padding: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .player-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 100px;
        }
        
        .player-info {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .player-timer {
            font-size: 0.8rem;
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 10px;
            margin-top: 3px;
            color: #4fc3f7;
            white-space: nowrap;
        }
        
        .player-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .player1-color {
            background: radial-gradient(circle at 30% 30%, #ff5252, #b33939);
        }
        
        .player2-color {
            background: radial-gradient(circle at 30% 30%, #448aff, #2962ff);
        }
        
        .status {
            font-size: 1rem;
            font-weight: bold;
            text-align: center;
            flex-grow: 1;
            padding: 0 8px;
            transition: all 0.3s ease;
        }
        
        /* 游戏状态文本颜色 */
        .player1-turn {
            color: #ff5252;
            text-shadow: 0 0 8px rgba(255, 82, 82, 0.5);
        }
        
        .player2-turn {
            color: #448aff;
            text-shadow: 0 0 8px rgba(68, 138, 255, 0.5);
        }
        
        .win-status {
            color: #4caf50;
            text-shadow: 0 0 12px rgba(76, 175, 80, 0.7);
            animation: pulse-text 2s infinite;
        }
        
        .draw-status {
            color: #ffeb3b;
            text-shadow: 0 0 12px rgba(255, 235, 59, 0.7);
            animation: pulse-text 2s infinite;
        }
        
        @keyframes pulse-text {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        /* 游戏网格区域 */
        .grid-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        .layer-container {
            background: rgba(20, 30, 48, 0.7);
            border-radius: 10px;
            padding: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            position: relative;
        }
        
        .layer-title {
            text-align: center;
            font-size: 0.85rem;
            margin-bottom: 5px;
            color: #81d4fa;
        }
        
        .layer {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 2px;
            background: rgba(30, 41, 59, 0.5);
            padding: 6px;
            border-radius: 6px;
        }
        
        .cell {
            width: 100%;
            aspect-ratio: 1/1;
            background: rgba(40, 53, 80, 0.5);
            border-radius: 4px;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .cell:active {
            transform: scale(0.95);
        }
        
        .cell::before, .cell::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .cell::before {
            width: 100%;
            height: 1px;
            top: 50%;
            left: 0;
        }
        
        .cell::after {
            width: 1px;
            height: 100%;
            left: 50%;
            top: 0;
        }
        
        .piece {
            position: absolute;
            top: 10%;
            left: 10%;
            width: 80%;
            height: 80%;
            border-radius: 50%;
            z-index: 2;
            transition: transform 0.3s ease;
        }
        
        .player1 {
            background: radial-gradient(circle at 30% 30%, #ff5252, #b33939);
        }
        
        .player2 {
            background: radial-gradient(circle at 30% 30%, #448aff, #2962ff);
        }
        
        .piece.placed {
            transform: scale(1);
        }
        
        .winning-piece {
            animation: pulse 1.5s infinite;
            box-shadow: 0 0 8px gold, 0 0 15px gold;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        /* 闪烁动画 - 无效位置 */
        @keyframes blink {
            0% { background-color: rgba(255, 0, 0, 0.3); }
            50% { background-color: rgba(255, 0, 0, 0.7); }
            100% { background-color: rgba(255, 0, 0, 0.3); }
        }
        
        .invalid-cell {
            animation: blink 0.8s ease 3;
        }
        
        /* 3D视图区域 */
        .view-section {
            background: rgba(20, 30, 48, 0.7);
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            height: 180px; /* 缩小高度 */
        }
        
        #three-container {
            width: 100%;
            height: 100%;
            border-radius: 8px;
            overflow: hidden;
            background: #0a0f1a;
        }
        
        /* 规则弹窗 */
        .rules-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .rules-modal.active {
            opacity: 1;
            visibility: visible;
        }
        
        .rules-content {
            background: linear-gradient(135deg, #1a2a6c, #2c3e50);
            width: 90%;
            max-width: 400px;
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            position: relative;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 30px;
            height: 30px;
            background: #ff5252;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
            font-size: 18px;
        }
        
        .rules-title {
            text-align: center;
            font-size: 1.4rem;
            margin-bottom: 15px;
            color: #4fc3f7;
        }
        
        .rules-list {
            padding-left: 20px;
        }
        
        .rules-list li {
            margin-bottom: 10px;
            line-height: 1.5;
        }
        
        /* 响应式调整 */
        @media (min-width: 768px) {
            .header-container {
                padding: 12px;
            }
            
            .game-title {
                font-size: 1.3rem;
            }
            
            .status {
                font-size: 1.1rem;
            }
            
            .layer {
                padding: 8px;
                gap: 3px;
            }
            
            .view-section {
                height: 220px; /* 缩小高度 */
            }
            
            .player-indicator {
                min-width: 120px;
            }
            
            .player-timer {
                font-size: 0.9rem;
            }
        }
        
        @media (max-width: 480px) {
            .player-indicator {
                min-width: 90px;
                gap: 6px;
            }
            
            .player-timer {
                font-size: 0.7rem;
                padding: 1px 5px;
            }
            
            .status {
                font-size: 0.9rem;
            }
            
            .header-controls {
                gap: 8px;
            }
            
            .header-btn {
                width: 32px;
                height: 32px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <!-- 顶部标题栏 -->
    <div class="header-container">
        <div class="logo">
            <div class="logo-icon">4</div>
            <h1 class="game-title">立体四子棋</h1>
        </div>
        
        <div class="header-controls">
            <div class="header-btn" id="restart" title="重新开始">
                <i class="fas fa-redo"></i>
            </div>
            <div class="header-btn" id="undo" title="悔棋">
                <i class="fas fa-undo"></i>
            </div>
            <div class="header-btn" id="reset-view" title="重置3D视图">
                <i class="fas fa-crosshairs"></i>
            </div>
            <div class="header-btn" id="show-rules" title="游戏规则">
                <i class="fas fa-question"></i>
            </div>
        </div>
    </div>
    
    <!-- 主游戏区域 -->
    <div class="game-container">
        <!-- 状态栏 -->
        <div class="status-bar">
            <div class="player-indicator">
                <div class="player-color player1-color"></div>
                <div class="player-info">
                    <span>玩家1</span>
                    <div class="player-timer" id="player1-timer">00:00</div>
                </div>
            </div>
            
            <div class="status player1-turn" id="status">玩家1回合</div>
            
            <div class="player-indicator" style="justify-content: end;">
                <div class="player-info">
                    <span>玩家2</span>
                    <div class="player-timer" id="player2-timer">00:00</div>
                </div>
                <div class="player-color player2-color"></div>
            </div>
        </div>
        
        <!-- 游戏网格 -->
        <div class="grid-container">
            <div class="layer-container">
                <div class="layer-title">第一层</div>
                <div class="layer" id="layer0"></div>
            </div>
            <div class="layer-container">
                <div class="layer-title">第二层</div>
                <div class="layer" id="layer1"></div>
            </div>
            <div class="layer-container">
                <div class="layer-title">第三层</div>
                <div class="layer" id="layer2"></div>
            </div>
            <div class="layer-container">
                <div class="layer-title">第四层</div>
                <div class="layer" id="layer3"></div>
            </div>
        </div>
        
        <!-- 3D视图 -->
        <div class="view-section">
            <div id="three-container"></div>
        </div>
    </div>
    
    <!-- 规则弹窗 -->
    <div class="rules-modal" id="rules-modal">
        <div class="rules-content">
            <div class="close-btn" id="close-rules">×</div>
            <h2 class="rules-title">游戏规则</h2>
            <ul class="rules-list">
                <li>两个玩家轮流在4×4×4的立方体网格中放置棋子</li>
                <li>玩家1使用红色棋子，玩家2使用蓝色棋子</li>
                <li>第一层（底层）可以直接放置棋子</li>
                <li>其他层放置棋子时，正下方位置必须有棋子支撑</li>
                <li>在任意方向（横、竖、斜）连成四子即可获胜</li>
                <li>获胜方向包括：水平线、垂直线、对角线、空间对角线</li>
                <li>点击网格放置棋子，使用3D视图查看棋盘</li>
            </ul>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // 游戏状态
            const gameState = {
                currentPlayer: 1,
                board: Array(4).fill().map(() => Array(4).fill().map(() => Array(4).fill(0))),
                gameOver: false,
                moveHistory: [],
                winningPieces: [],
                timers: {
                    1: 0, // 玩家1的时间（秒）
                    2: 0  // 玩家2的时间（秒）
                },
                currentTimer: null,
                lastMoveTime: Date.now(),
                initialCameraPosition: null
            };
            
            // Three.js 变量
            let scene, camera, renderer, controls;
            let boardGroup = new THREE.Group();
            let pieceMeshes = [];
            
            // 初始化Three.js场景
            function initThreeJS() {
                // 创建场景
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0a0f1a);
                scene.add(boardGroup);
                
                // 添加环境光
                const ambientLight = new THREE.AmbientLight(0x404040, 2);
                scene.add(ambientLight);
                
                // 添加平行光
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(5, 10, 7);
                scene.add(directionalLight);
                
                // 创建相机
                const container = document.getElementById('three-container');
                camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
                camera.position.set(6, 6, 6);
                camera.lookAt(0, 0, 0);
                
                // 保存初始相机位置
                gameState.initialCameraPosition = camera.position.clone();
                
                // 创建渲染器
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                container.appendChild(renderer.domElement);
                
                // 添加轨道控制器
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.enableZoom = true;
                controls.enablePan = false;
                
                // 创建棋盘框架
                createBoardFrame();
                
                // 渲染循环
                function animate() {
                    requestAnimationFrame(animate);
                    controls.update();
                    renderer.render(scene, camera);
                }
                animate();
                
                // 响应窗口大小变化
                window.addEventListener('resize', () => {
                    camera.aspect = container.clientWidth / container.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(container.clientWidth, container.clientHeight);
                });
            }
            
            // 创建棋盘框架
            function createBoardFrame() {
                // 创建层分隔线
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0x3a6a9c });
                
                for (let level = 0; level <= 4; level++) {
                    for (let i = 0; i < 4; i++) {
                        for (let j = 0; j < 4; j++) {
                            if (i < 3) {
                                // 水平线
                                const horizontalPoints = [];
                                horizontalPoints.push(new THREE.Vector3(j - 1.5, level - 2, i - 1.5));
                                horizontalPoints.push(new THREE.Vector3(j - 1.5, level - 2, i - 0.5));
                                
                                const horizontalLine = new THREE.Line(
                                    new THREE.BufferGeometry().setFromPoints(horizontalPoints),
                                    lineMaterial
                                );
                                boardGroup.add(horizontalLine);
                            }
                            
                            if (j < 3) {
                                // 垂直线
                                const verticalPoints = [];
                                verticalPoints.push(new THREE.Vector3(j - 1.5, level - 2, i - 1.5));
                                verticalPoints.push(new THREE.Vector3(j - 0.5, level - 2, i - 1.5));
                                
                                const verticalLine = new THREE.Line(
                                    new THREE.BufferGeometry().setFromPoints(verticalPoints),
                                    lineMaterial
                                );
                                boardGroup.add(verticalLine);
                            }
                        }
                    }
                }
            }
            
            // 添加3D棋子
            function add3DPiece(layer, row, col, player) {
                const pieceGeometry = new THREE.SphereGeometry(0.4, 32, 32);
                const pieceMaterial = new THREE.MeshPhongMaterial({
                    color: player === 1 ? 0xff5252 : 0x448aff,
                    emissive: 0x000000,
                    shininess: 60
                });
                
                const piece = new THREE.Mesh(pieceGeometry, pieceMaterial);
                piece.position.set(col - 1.5, layer - 1.5, row - 1.5);
                
                // 保存引用
                piece.userData = { layer, row, col, player };
                pieceMeshes.push(piece);
                boardGroup.add(piece);
                
                // 添加动画效果
                animatePieceScale(piece);
            }
            
            // 高亮获胜的棋子
            function highlightWinningPieces(winningPieces) {
                // 重置所有棋子高亮
                pieceMeshes.forEach(piece => {
                    piece.material.emissive.setHex(0x000000);
                    piece.material.needsUpdate = true;
                });
                
                // 高亮获胜的棋子
                winningPieces.forEach(pos => {
                    const piece = pieceMeshes.find(p => 
                        p.userData.layer === pos.layer &&
                        p.userData.row === pos.row &&
                        p.userData.col === pos.col
                    );
                    
                    if (piece) {
                        piece.material.emissive.setHex(0xffff00);
                        piece.material.needsUpdate = true;
                    }
                });
            }
            
            // 简单的动画函数
            function animatePieceScale(piece) {
                const startTime = Date.now();
                const duration = 400;
                
                function animate() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // 弹性动画效果
                    const scale = progress < 0.5 
                        ? 2 * progress * progress 
                        : -1 + (4 - 2 * progress) * progress;
                    
                    piece.scale.set(scale, scale, scale);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    }
                }
                
                animate();
            }
            
            // 初始化棋盘
            function initBoard() {
                for (let layer = 0; layer < 4; layer++) {
                    const layerElement = document.getElementById(`layer${layer}`);
                    layerElement.innerHTML = '';
                    
                    for (let row = 0; row < 4; row++) {
                        for (let col = 0; col < 4; col++) {
                            const cell = document.createElement('div');
                            cell.className = 'cell';
                            cell.dataset.layer = layer;
                            cell.dataset.row = row;
                            cell.dataset.col = col;
                            
                            cell.addEventListener('click', () => makeMove(layer, row, col));
                            
                            layerElement.appendChild(cell);
                        }
                    }
                }
            }
            
            // 重置3D视图
            function reset3DView() {
                animateCamera(camera.position, gameState.initialCameraPosition.clone(), new THREE.Vector3(0, 0, 0));
            }
            
            // 相机动画
            function animateCamera(fromPos, toPos, lookAt) {
                const duration = 1000;
                const startTime = Date.now();
                const startPos = fromPos.clone();
                
                function update() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // 使用缓动函数
                    const easeProgress = easeInOutCubic(progress);
                    
                    // 更新相机位置
                    camera.position.lerpVectors(startPos, toPos, easeProgress);
                    
                    // 让相机始终看向目标位置
                    camera.lookAt(lookAt);
                    
                    if (progress < 1) {
                        requestAnimationFrame(update);
                    } else {
                        // 更新控制器目标
                        controls.target.copy(lookAt);
                    }
                }
                
                update();
            }
            
            // 缓动函数
            function easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }
            
            // 开始计时器
            function startTimer() {
                if (gameState.currentTimer) {
                    clearInterval(gameState.currentTimer);
                }
                
                gameState.lastMoveTime = Date.now();
                
                gameState.currentTimer = setInterval(() => {
                    const now = Date.now();
                    const elapsedSeconds = Math.floor((now - gameState.lastMoveTime) / 1000);
                    gameState.timers[gameState.currentPlayer] += elapsedSeconds;
                    gameState.lastMoveTime = now;
                    
                    updateTimerDisplay();
                }, 1000);
            }
            
            // 更新计时器显示
            function updateTimerDisplay() {
                // 更新玩家1计时器
                const minutes1 = Math.floor(gameState.timers[1] / 60);
                const seconds1 = gameState.timers[1] % 60;
                document.getElementById('player1-timer').textContent = 
                    `${minutes1.toString().padStart(2, '0')}:${seconds1.toString().padStart(2, '0')}`;
                
                // 更新玩家2计时器
                const minutes2 = Math.floor(gameState.timers[2] / 60);
                const seconds2 = gameState.timers[2] % 60;
                document.getElementById('player2-timer').textContent = 
                    `${minutes2.toString().padStart(2, '0')}:${seconds2.toString().padStart(2, '0')}`;
            }
            
            // 更新状态文本样式
            function updateStatusStyle() {
                const statusElement = document.getElementById('status');
                
                // 移除所有样式类
                statusElement.classList.remove('player1-turn', 'player2-turn', 'win-status', 'draw-status');
                
                if (gameState.gameOver) {
                    if (statusElement.textContent.includes('获胜')) {
                        statusElement.classList.add('win-status');
                    } else {
                        statusElement.classList.add('draw-status');
                    }
                } else {
                    if (gameState.currentPlayer === 1) {
                        statusElement.classList.add('player1-turn');
                    } else {
                        statusElement.classList.add('player2-turn');
                    }
                }
            }
            
            // 下棋
            function makeMove(layer, row, col) {
                if (gameState.gameOver) return;
                
                // 检查位置是否有效
                if (gameState.board[layer][row][col] !== 0) return;
                
                // 检查下方是否有支撑（第一层除外）
                if (layer > 0 && gameState.board[layer-1][row][col] === 0) {
                    // 高亮显示下方需要支撑的位置
                    const belowCell = document.querySelector(`.cell[data-layer="${layer-1}"][data-row="${row}"][data-col="${col}"]`);
                    if (belowCell) {
                        belowCell.classList.add('invalid-cell');
                        setTimeout(() => {
                            belowCell.classList.remove('invalid-cell');
                        }, 2400);
                    }
                    
                    // 高亮显示当前尝试的位置
                    const currentCell = document.querySelector(`.cell[data-layer="${layer}"][data-row="${row}"][data-col="${col}"]`);
                    if (currentCell) {
                        currentCell.classList.add('invalid-cell');
                        setTimeout(() => {
                            currentCell.classList.remove('invalid-cell');
                        }, 2400);
                    }
                    
                    return;
                }
                
                // 停止当前计时器，记录时间
                if (gameState.currentTimer) {
                    clearInterval(gameState.currentTimer);
                    const now = Date.now();
                    const elapsedSeconds = Math.floor((now - gameState.lastMoveTime) / 1000);
                    gameState.timers[gameState.currentPlayer] += elapsedSeconds;
                }
                
                // 记录移动历史
                gameState.moveHistory.push({layer, row, col, player: gameState.currentPlayer});
                
                // 更新棋盘状态
                gameState.board[layer][row][col] = gameState.currentPlayer;
                
                // 在2D棋盘上放置棋子
                const cell = document.querySelector(`.cell[data-layer="${layer}"][data-row="${row}"][data-col="${col}"]`);
                const piece = document.createElement('div');
                piece.className = `piece player${gameState.currentPlayer}`;
                cell.appendChild(piece);
                
                // 添加动画效果
                setTimeout(() => {
                    piece.classList.add('placed');
                }, 10);
                
                // 添加3D棋子
                add3DPiece(layer, row, col, gameState.currentPlayer);
                
                // 检查是否获胜
                const winInfo = checkWin(layer, row, col);
                if (winInfo.win) {
                    gameState.gameOver = true;
                    gameState.winningPieces = winInfo.winningPieces;
                    document.getElementById('status').textContent = `玩家${gameState.currentPlayer}获胜！`;
                    highlightWinningPieces(winInfo.winningPieces);
                    highlight2DWinningPieces();
                    updateStatusStyle();
                    return;
                }
                
                // 检查是否平局
                if (checkDraw()) {
                    gameState.gameOver = true;
                    document.getElementById('status').textContent = '平局！';
                    updateStatusStyle();
                    return;
                }
                
                // 切换玩家
                gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
                document.getElementById('status').textContent = `玩家${gameState.currentPlayer}回合`;
                updateStatusStyle();
                
                // 为新玩家启动计时器
                startTimer();
            }
            
            // 高亮2D获胜棋子
            function highlight2DWinningPieces() {
                // 高亮获胜棋子
                gameState.winningPieces.forEach(pos => {
                    const cell = document.querySelector(`.cell[data-layer="${pos.layer}"][data-row="${pos.row}"][data-col="${pos.col}"]`);
                    if (cell && cell.firstChild) {
                        cell.firstChild.classList.add('winning-piece');
                    }
                });
            }
            
            // 检查是否获胜
            function checkWin(layer, row, col) {
                const player = gameState.board[layer][row][col];
                if (player === 0) return { win: false, winningPieces: [] };
                
                // 检查方向
                const directions = [
                    // 同一层方向
                    [0, 0, 1], [0, 1, 0], [0, 1, 1], [0, 1, -1],
                    
                    // 垂直方向
                    [1, 0, 0],
                    
                    // 垂直平面内的对角线
                    [1, 1, 0], [1, -1, 0], [1, 0, 1], [1, 0, -1],
                    
                    // 空间对角线
                    [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1],
                    
                    // 垂直平面内的其他斜线方向
                    [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1],
                    [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1]
                ];
                
                for (const [dl, dr, dc] of directions) {
                    let count = 1;
                    let winningPieces = [];
                    
                    // 正向检查
                    const forward = countDirection(layer, row, col, dl, dr, dc, player);
                    count += forward.count;
                    winningPieces = winningPieces.concat(forward.pieces);
                    
                    // 反向检查
                    const backward = countDirection(layer, row, col, -dl, -dr, -dc, player);
                    count += backward.count;
                    winningPieces = winningPieces.concat(backward.pieces);
                    
                    if (count >= 4) {
                        winningPieces.push({layer, row, col});
                        return {
                            win: true,
                            winningPieces: winningPieces.slice(0, 4)
                        };
                    }
                }
                
                return { win: false, winningPieces: [] };
            }
            
            // 计算指定方向上的连续棋子数
            function countDirection(layer, row, col, dl, dr, dc, player) {
                let count = 0;
                let pieces = [];
                let l = layer + dl;
                let r = row + dr;
                let c = col + dc;
                
                while (l >= 0 && l < 4 && r >= 0 && r < 4 && c >= 0 && c < 4) {
                    if (gameState.board[l][r][c] === player) {
                        count++;
                        pieces.push({layer: l, row: r, col: c});
                        l += dl;
                        r += dr;
                        c += dc;
                    } else {
                        break;
                    }
                }
                
                return { count, pieces };
            }
            
            // 检查是否平局
            function checkDraw() {
                for (let layer = 0; layer < 4; layer++) {
                    for (let row = 0; row < 4; row++) {
                        for (let col = 0; col < 4; col++) {
                            if (gameState.board[layer][row][col] === 0) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }
            
            // 悔棋
            function undoMove() {
                if (gameState.gameOver || gameState.moveHistory.length === 0) return;
                
                // 停止计时器
                if (gameState.currentTimer) {
                    clearInterval(gameState.currentTimer);
                    const now = Date.now();
                    const elapsedSeconds = Math.floor((now - gameState.lastMoveTime) / 1000);
                    gameState.timers[gameState.currentPlayer] += elapsedSeconds;
                }
                
                const lastMove = gameState.moveHistory.pop();
                gameState.board[lastMove.layer][lastMove.row][lastMove.col] = 0;
                
                // 移除2D棋子
                const cell = document.querySelector(`.cell[data-layer="${lastMove.layer}"][data-row="${lastMove.row}"][data-col="${lastMove.col}"]`);
                cell.innerHTML = '';
                
                // 移除3D棋子
                const index = pieceMeshes.findIndex(piece => 
                    piece.userData.layer === lastMove.layer &&
                    piece.userData.row === lastMove.row &&
                    piece.userData.col === lastMove.col
                );
                
                if (index !== -1) {
                    boardGroup.remove(pieceMeshes[index]);
                    pieceMeshes.splice(index, 1);
                }
                
                // 重置获胜状态
                gameState.winningPieces = [];
                highlightWinningPieces([]);
                document.querySelectorAll('.winning-piece').forEach(piece => {
                    piece.classList.remove('winning-piece');
                });
                
                // 切换回上一个玩家
                gameState.currentPlayer = lastMove.player;
                document.getElementById('status').textContent = `玩家${gameState.currentPlayer}回合`;
                gameState.gameOver = false;
                updateStatusStyle();
                
                // 启动计时器
                startTimer();
            }
            
            // 重新开始游戏
            function restartGame() {
                // 停止计时器
                if (gameState.currentTimer) {
                    clearInterval(gameState.currentTimer);
                    gameState.currentTimer = null;
                }
                
                // 重置游戏状态
                gameState.currentPlayer = 1;
                gameState.board = Array(4).fill().map(() => Array(4).fill().map(() => Array(4).fill(0)));
                gameState.gameOver = false;
                gameState.moveHistory = [];
                gameState.winningPieces = [];
                gameState.timers = {1: 0, 2: 0};
                
                // 更新UI
                document.querySelectorAll('.piece').forEach(piece => piece.remove());
                document.getElementById('status').textContent = '玩家1回合';
                updateTimerDisplay();
                updateStatusStyle();
                
                // 移除获胜高亮
                document.querySelectorAll('.winning-piece').forEach(piece => {
                    piece.classList.remove('winning-piece');
                });
                
                // 重置3D棋盘
                pieceMeshes.forEach(piece => boardGroup.remove(piece));
                pieceMeshes = [];
                
                // 重置3D视图
                reset3DView();
            }
            
            // 规则弹窗控制
            function toggleRulesModal() {
                document.getElementById('rules-modal').classList.toggle('active');
            }
            
            // 事件监听
            document.getElementById('restart').addEventListener('click', restartGame);
            document.getElementById('undo').addEventListener('click', undoMove);
            document.getElementById('reset-view').addEventListener('click', reset3DView);
            document.getElementById('show-rules').addEventListener('click', toggleRulesModal);
            document.getElementById('close-rules').addEventListener('click', toggleRulesModal);
            
            // 初始化游戏
            initBoard();
            initThreeJS();
        });
    </script>
</body>
</html>